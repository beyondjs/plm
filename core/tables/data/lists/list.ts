import {SingleCall} from "@beyond-js/kernel/core";
import {Product} from "../factory/product";
import type {ListsManager} from "./manager/manager";
import {FilterSpecs, Filter} from "../filter/filter";
import {ListFetcher} from "./fetcher";
import {ListLocalStore} from "./local-store";
import {ListRecords} from "./records";
import {Order, OrderSpecs} from "./order";

export class ListData extends Product {
    readonly #filter: Filter
    get filter() {
        return this.#filter;
    }

    readonly #order: Order
    get order() {
        return this.#order;
    }

    #error: string;
    get error() {
        return this.#error;
    }

    set error(value: string) {
        this.#error = value;
    }

    get valid() {
        return !this.#error;
    }

    #invalidated = false;

    // For realtime notifications to indicate that the list has changed
    invalidate() {
        this.#invalidated = true;
        this.trigger('invalidated');
    }

    readonly #records = new ListRecords(this);
    get records() {
        return this.#records;
    }

    // The local store, properties and methods
    #localStore = new ListLocalStore(this);
    get localStore() {
        return this.#localStore;
    }

    get loaded() {
        return this.#localStore.loaded;
    }

    @SingleCall
    async load() {
        let stored: (string | number)[];
        try {
            stored = await this.#localStore.load();
        } catch (exc) {
            console.error(`Error loading list from cache`, exc.stack);
            return;
        }

        if (stored === undefined) return;

        if (!(stored instanceof Array)) {
            console.warn('Invalid list data cache', this);
        } else {
            stored && this.#records.overwrite(stored);
            this.trigger('change');
            this.trigger('updated');
        }
    }

    // The fetch manager, properties and methods
    readonly #fetcher = new ListFetcher(this);

    get fetching() {
        return this.#fetcher.fetching;
    }

    get fetched() {
        return this.#fetcher.fetched;
    }

    async fetch() {
        await this.#fetcher.fetch();
    }

    /**
     * ListData Constructor
     * @param {ListsManager} manager The manager of the list (instance of a factory)
     * @param {string} key The key generated by CompareObjects.generate(filter, session)
     * @param {number} instanceId The auto-numeric instance id generated by the manager
     * @param {FilterSpecs} filterSpecs The filter specification
     * @param {OrderSpecs} orderSpecs The order specification
     */
    constructor(manager: ListsManager, key: string, instanceId: number, filterSpecs: FilterSpecs, orderSpecs: OrderSpecs) {
        super(manager, key, instanceId);
        this.#filter = new Filter(this.table, filterSpecs);
        this.#order = new Order(this.table, orderSpecs);
    }

    destroy() {
        this.#records.destroy();
    }
}
